# Introduction

The central theme of the book is GraphQL in modern applications. Even though GraphQL is only a specification and can be used in many programming languages, this book teaches GraphQL only in JavaScript. Facebook, the company behind the GraphQL specification, didn't release without any reason GraphQL's reference implementation in JavaScript. It is the most compelling programming languages for companies and their client-server architecture nowadays. However, by using Facebook's specification as their blueprint, other programming languages such as Python and Java followed eventually. For me it was only a lucky coincidence that a former coworker of mine open sourced the GraphQL implementation for Java. He wanted to be one of the first people contributing to it, worked every night to make it happen, was not too well during the day time, but managed to open source it as the status quo implementation for Java.

GraphQL is only a query language which could be used anywhere, but most often it bridges the chasm between client and server applications. By using a network layer of your choice, because GraphQL isn't opinionated about those things, you can read and write data with GraphQL between a client and server application(s). Just considering JavaScript here, GraphQL is used to complement the network stack for many libraries and frameworks out there. On the client-side, it can be used in popular solutions such as React, Angular, and Vue, but also on the server-side it is not opinionated about a middleware library (Express, Koa, Hapi) when using it in a Node.js environment. After all, you can just send GraphQL operations with plain HTTP across the wire.

GraphQL introduces a new era in web development. Whereas RESTful applications were an all time favorite for enabling the data transfer between client and server applications, the requirements in modern applications shifted. Nowadays there are more than one client (desktop, web, mobile, wearable) which are interested in a API exposed by a server application. And every client has its different needs. So either you would implement these different needs with multiple client specific APIs when sticking to REST or offer only one API with GraphQL for all your client applications. But GraphQL is so much more than only being a unified interface between your applications. The ecosystem around it offers you so many possibilities to develop powerful applications with it. So I hope you are excited as I am for this new GraphQL era.

Not only the experience of my coworker working on the GraphQL implementation for Java shaped my own thinking about GraphQL, but also my former company evaluated GraphQL for their enterprise application. The glue between our client and server application was largely influenced by REST. However, even though we had all those API endpoints for our almost RESTful resources in place, we eventually ran into similar issues like other companies (e.g. Facebook) for our API consuming client application(s). The API endpoints were just too rigid and hence you had to come up with aggregations or modifications of those endpoints. Whereas an aggregation would mean putting to resources into one API endpoint, a modification would mean to offer multiple variations of an API endpoint to request different representations of a resource. Thus we introduced our own implementation to tell a server as a client in which information we are interested for a particular resource. At least that's how it was possible to stay away from the modifications of certain endpoints. But the aggregations of the endpoints were still in place. Basically we had our own naive implementation of GraphQL with the limitation of only being able to query one resource and not relationships. From a client-side perspective, only Relay for React was released as sophisticated library to consume GraphQL APIs. So we invested time into this as well. In the end, GraphQL was in its too early stages and we postponed the vital decision of introducing it in our tech stack. No one would have anticipated that it becomes so popular, powerful and stable.

This book starts with teaching GraphQL in client-side applications. Therefore you will use React as UI library to consume your first third-party GraphQL API which happens to be GitHub's GraphQL API. This API is a popular choice among developers for learning GraphQL, because of a couple of reasons. Firstly, GitHub was one out of a few popular companies who made their GraphQL API public. Secondly, since many people are using the API and GitHub is a grown company, there is much trust in the API for being stable. And thirdly, using a third-party API comes with the benefit of just focusing on the client-side for GraphQL in the beginning. You are learning about how to consume a GraphQL API in a client application without bothering about exposing a GraphQL API in a server application in the first place.

GitHub's GraphQL API will be used throughout this book for learning GraphQL from a client-side perspective. Only when you start to shift gears towards learning GraphQL in server-side applications, you will implement your own GraphQL API which you can consume eventually in your client applications. In the end, you should have learned almost every aspect about GraphQL in JavaScript applications. I am saying almost here, because even though the book is kept up to date, there are always new things, be it libraries, patterns or best practices, coming up for it.

I sincerely hope the book gives you the optimal learning experience to get to know GraphQL for your JavaScript client and server applications. Even though you are not using React or Express in your day to day work, you should be able to apply these learnings in other solutions such as Angular, Vue, Koa or Hapi as well. Therefore, I wish you all the best on this journey mastering GraphQL for modern client-server applications.